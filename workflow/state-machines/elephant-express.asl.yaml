Comment: Elephant Express workflow. Triggered by Starter Lambda with one SQS message payload.
StartAt: CheckDirectSubmit
States:
  CheckDirectSubmit:
    Type: Choice
    Comment: "Check if this is a direct-submit execution (transactionItems provided in message)"
    Choices:
      - Variable: $.message.hash.transactionItems
        IsPresent: true
        Next: PrepareDirectSubmitInput
    Default: Preprocess

  PrepareDirectSubmitInput:
    Type: Pass
    QueryLanguage: JSONata
    Comment: "Restructure direct-submit input from { message: { pre, hash } } to { pre, hash } at root level"
    Output: >-
      {%
        {
          "pre": $states.input.message.pre,
          "hash": $states.input.message.hash
        }
      %}
    Next: EmitSubmitScheduled

  Preprocess:
    Type: Task
    Resource: arn:aws:states:::lambda:invoke
    Parameters:
      FunctionName: ${WorkflowPreProcessorFunction}
      Payload.$: $.message
    ResultSelector:
      county_prep_input_s3_uri.$: $.Payload.county_prep_input_s3_uri
      output_prefix.$: $.Payload.output_prefix
      seed_output_s3_uri.$: $.Payload.seed_output_s3_uri
      county_name.$: $.Payload.county_name
      county_key.$: $.Payload.county_key
    ResultPath: $.pre
    Next: BuildRepairParamName
    Retry:
      - ErrorEquals:
          [
            Lambda.ServiceException,
            Lambda.AWSLambdaException,
            Lambda.SdkClientException,
          ]
        IntervalSeconds: 2
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.preprocessError
        Next: WaitForPreprocessResolution

  WaitForPreprocessResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    Comment: "Emit FAILED event for Preprocess and wait for external resolution"
    HeartbeatSeconds: 2592000 # 30 days
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county: "unknown"
            status: FAILED
            phase: Preprocess
            step: Preprocess
            dataGroupLabel: County
            taskToken.$: $$.Task.Token
            errors:
              - code: "00001"
                details:
                  error.$: States.JsonToString($.preprocessError)
    ResultPath: $.resolutionResult
    Next: Preprocess
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "EventBridge emit failed - stay parked and wait again"
        ResultPath: $.preprocessError
        Next: WaitForPreprocessResolution

  BuildRepairParamName:
    Type: Pass
    Parameters:
      repairParam.$: States.Format('/${StackName}/repair/{}', $.pre.county_key)
    ResultPath: $.repair
    Next: GetCountyRepairFlag

  GetCountyRepairFlag:
    Type: Task
    Resource: arn:aws:states:::aws-sdk:ssm:getParameter
    Parameters:
      Name.$: $.repair.repairParam
      WithDecryption: false
    ResultPath: $.countyRepair
    Next: ShouldAttemptSkip
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.countyRepair
        Next: DefaultRepairTrue

  DefaultRepairTrue:
    Type: Pass
    Parameters:
      Parameter:
        Value: "true"
    ResultPath: $.countyRepair
    Next: ShouldAttemptSkip

  ShouldAttemptSkip:
    Type: Choice
    Choices:
      - Variable: $.countyRepair.Parameter.Value
        StringEquals: "true"
        Next: BuildHeadParams
    Default: EmitPrepareScheduled

  BuildHeadParams:
    Type: Pass
    QueryLanguage: JSONata
    Comment: "Parse pre.output_prefix (s3://bucket/prefix) to derive bucket, key (prefix/output.zip), and expectedOutputUri"
    Output: >-
      {%
        {
          "head": {
            "bucket": $split($split($states.input.pre.output_prefix, "s3://")[1], "/")[0],
            "key": $substringAfter($states.input.pre.output_prefix, "s3://" & $split($split($states.input.pre.output_prefix, "s3://")[1], "/")[0] & "/") & '/output.zip',
            "expectedOutputUri": $states.input.pre.output_prefix & '/output.zip'
          },
          "message": $states.input.message,
          "pre": $states.input.pre
        }
      %}
    Next: HeadOutputZip

  HeadOutputZip:
    Type: Task
    Resource: arn:aws:states:::aws-sdk:s3:headObject
    Parameters:
      Bucket.$: $.head.bucket
      Key.$: $.head.key
    ResultPath: $.headResult
    Next: BypassPrepare
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.headError
        Next: EmitPrepareScheduled

  BypassPrepare:
    Type: Pass
    Parameters:
      output_s3_uri.$: $.head.expectedOutputUri
      prepareSkipped: true
    ResultPath: $.prepare
    Next: EmitBypassPrepareSucceeded

  EmitBypassPrepareSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: Prepare
            step: Prepare
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: EmitTransformScheduled
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: EmitTransformScheduled

  EmitPrepareScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: Prepare
            step: Prepare
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: GetPrepareQueueUrl
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: GetPrepareQueueUrl

  GetPrepareQueueUrl:
    Type: Task
    Resource: arn:aws:states:::aws-sdk:sqs:getQueueUrl
    QueryLanguage: JSONata
    Comment: "Get queue URL by name (lowercase, spaces replaced with hyphens). Throws Sqs.QueueDoesNotExistException if queue not found."
    Arguments:
      QueueName: "{% '${StackName}-prepare-queue-' & $replace($replace($lowercase($states.input.pre.county_name), ' ', '-'), '.', '') %}"
    Output: "{% $merge([$states.input, { 'queue': $states.result }]) %}"
    Next: Prepare
    Catch:
      - ErrorEquals: [Sqs.QueueDoesNotExistException]
        Output: "{% $merge([$states.input, { 'prepareError': $states.errorOutput }]) %}"
        Next: EmitPrepareQueueNotFound

  Prepare:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Send prepare job to SQS queue. Lambda downloads input from S3, runs prepare, uploads output, and calls back with task token."
    Parameters:
      QueueUrl.$: $.queue.QueueUrl
      MessageBody:
        taskToken.$: $$.Task.Token
        executionId.$: $$.Execution.Name
        input_s3_uri.$: $.pre.county_prep_input_s3_uri
        output_s3_uri_prefix.$: $.pre.output_prefix
        browser: true
        county.$: $.pre.county_name
    ResultSelector:
      output_s3_uri.$: $.output_s3_uri
      county.$: $.county
      taskToken.$: $.taskToken
      prepareSkipped: false
    ResultPath: $.prepare
    Next: ReportPrepareLambdaSuccess
    Retry:
      - ErrorEquals:
          [
            Lambda.ServiceException,
            Lambda.AWSLambdaException,
            Lambda.SdkClientException,
          ]
        IntervalSeconds: 5
        MaxAttempts: 3
        BackoffRate: 2
    Catch:
      - ErrorEquals: [States.Timeout]
        ResultPath: $.prepareError
        Next: EmitPrepareFailed
      - ErrorEquals: [States.ALL]
        ResultPath: $.prepareError
        Next: EmitPrepareFailed

  EmitPrepareQueueNotFound:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    Comment: "Emit FAILED event with taskToken when queue not found. Waits for external retry (e.g., after queue is created)."
    HeartbeatSeconds: 2592000 # 30 days
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: FAILED
            phase: Prepare
            step: Prepare
            dataGroupLabel: County
            taskToken.$: $$.Task.Token
            errors:
              - code: "01001"
                details.$: $.prepareError
    ResultPath: $.queueNotFoundResult
    Next: GetPrepareQueueUrl
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "EventBridge emit failed - stay parked and wait again"
        ResultPath: $.error
        Next: EmitPrepareQueueNotFound

  ReportPrepareLambdaSuccess:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.prepare.county
            status: SUCCEEDED
            phase: Prepare
            step: Prepare
            dataGroupLabel: County
            taskToken.$: $.prepare.taskToken
    ResultPath: $.eventResult
    Next: EmitTransformScheduled
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: EmitTransformScheduled

  EmitPrepareFailed:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    QueryLanguage: JSONata
    Comment: "Emit FAILED event with actual error code from Lambda. Waits for external sendTaskSuccess to resume."
    HeartbeatSeconds: 2592000 # 30 days
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: Prepare
            step: Prepare
            dataGroupLabel: County
            taskToken: "{% $states.context.Task.Token %}"
            errors:
              - code: "{% $states.input.prepareError.Error %}"
                details:
                  cause: "{% $states.input.prepareError.Cause %}"
    Output: "{% $merge([$states.input, { 'failedResult': $states.result }]) %}"
    Next: Prepare
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "EventBridge emit failed - stay parked and wait again"
        Output: "{% $merge([$states.input, { 'error': $states.errorOutput }]) %}"
        Next: EmitPrepareFailed

  # === TRANSFORM STEP ===

  EmitTransformScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for Transform step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: Transform
            step: Transform
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: Transform
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: Transform

  Transform:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Run Transform step via SQS + Lambda worker with task token callback"
    Parameters:
      QueueUrl: ${TransformQueueUrl}
      MessageBody:
        taskToken.$: $$.Task.Token
        input:
          inputS3Uri.$: $.prepare.output_s3_uri
          county.$: $.pre.county_name
          outputPrefix.$: $.pre.output_prefix
          executionId.$: $$.Execution.Name
    ResultSelector:
      transformedOutputS3Uri.$: $.transformedOutputS3Uri
      county.$: $.county
      executionId.$: $$.Execution.Name
    ResultPath: $.transform
    Next: EmitTransformSucceeded
    Retry:
      - ErrorEquals: [States.Timeout]
        IntervalSeconds: 5
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [ScriptsFailedError]
        Comment: "Transform scripts failed - park for resolution"
        ResultPath: $.transformError
        Next: WaitForTransformResolution
      - ErrorEquals: [States.ALL]
        ResultPath: $.transformError
        Next: WaitForTransformResolution

  EmitTransformSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SUCCEEDED event for Transform step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: Transform
            step: Transform
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: EmitSvlScheduled
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: EmitSvlScheduled

  WaitForTransformResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    QueryLanguage: JSONata
    Comment: "Emit FAILED event and wait for external resolution - retry target is Transform"
    HeartbeatSeconds: 2592000 # 30 days
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: Transform
            step: Transform
            dataGroupLabel: County
            taskToken: "{% $states.context.Task.Token %}"
            errors:
              - code: "{% '20' & $states.input.pre.county_name %}"
                details:
                  error: "{% $string($states.input.transformError) %}"
    Output: "{% $states.input %}"
    Next: Transform
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        Output: "{% $states.input %}"
        Next: WaitForTransformResolution

  # === SVL (Schema Validation Layer) STEP ===

  EmitSvlScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for SVL step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: SVL
            step: SVL
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: SVL
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: SVL

  SVL:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Run Schema Validation Layer via SQS + Lambda worker"
    Parameters:
      QueueUrl: ${SvlQueueUrl}
      MessageBody:
        taskToken.$: $$.Task.Token
        input:
          transformedOutputS3Uri.$: $.transform.transformedOutputS3Uri
          county.$: $.pre.county_name
          outputPrefix.$: $.pre.output_prefix
          executionId.$: $$.Execution.Name
          preparedS3Uri.$: $.prepare.output_s3_uri
          s3.$: $.message.s3
    ResultSelector:
      validatedOutputS3Uri.$: $.validatedOutputS3Uri
      county.$: $.county
      executionId.$: $$.Execution.Name
      validationPassed.$: $.validationPassed
      svlErrors.$: $.svlErrors
    ResultPath: $.svl
    Next: CheckSvlResult
    Retry:
      - ErrorEquals: [States.Timeout]
        IntervalSeconds: 5
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [SvlFailedError]
        Comment: "SVL validation failed - park for resolution"
        ResultPath: $.svlError
        Next: WaitForSvlExceptionResolution
      - ErrorEquals: [States.ALL]
        ResultPath: $.svlError
        Next: WaitForSvlExceptionResolution

  CheckSvlResult:
    Type: Choice
    Comment: "Check if SVL validation passed or failed (errors saved to DynamoDB)"
    Choices:
      - Variable: $.svl.validationPassed
        BooleanEquals: false
        Next: WaitForSvlValidationResolution
    Default: EmitSvlSucceeded

  EmitSvlSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SUCCEEDED event for SVL step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: SVL
            step: SVL
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: EmitHashScheduled
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: EmitHashScheduled

  WaitForSvlValidationResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    QueryLanguage: JSONata
    Comment: "Emit FAILED event with individual validation errors and wait for external resolution - retry target is Transform"
    HeartbeatSeconds: 2592000 # 30 days
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: SVL
            step: SVL
            dataGroupLabel: County
            taskToken: "{% $states.context.Task.Token %}"
            errors: >-
              {%
                [$states.input.svl.svlErrors ~> $map(function($e) {
                  {
                    "code": "30" & $e.error_hash,
                    "details": {
                      "error_message": $e.error_message,
                      "error_path": $e.error_path,
                      "data_group_cid": $e.data_group_cid,
                      "error_hash": $e.error_hash
                    }
                  }
                })]
              %}
    Output: "{% $states.input %}"
    Next: Transform
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        Output: "{% $states.input %}"
        Next: WaitForSvlValidationResolution

  WaitForSvlExceptionResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    Comment: "Emit FAILED event for SVL exception and wait for external resolution - retry target is Transform"
    HeartbeatSeconds: 2592000 # 30 days
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: FAILED
            phase: SVL
            step: SVL
            dataGroupLabel: County
            taskToken.$: $$.Task.Token
            errors:
              - code: "31001"
                details:
                  error.$: States.JsonToString($.svlError)
    ResultPath: $.resolutionResult
    Next: Transform
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        ResultPath: $.svlError
        Next: WaitForSvlExceptionResolution

  # === HASH STEP ===

  EmitHashScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for Hash step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: Hash
            step: Hash
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: Hash
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: Hash

  Hash:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Run Hash generation via SQS + Lambda worker"
    Parameters:
      QueueUrl: ${HashQueueUrl}
      MessageBody:
        taskToken.$: $$.Task.Token
        input:
          validatedOutputS3Uri.$: $.transform.transformedOutputS3Uri
          seedOutputS3Uri.$: $.pre.seed_output_s3_uri
          county.$: $.pre.county_name
          outputPrefix.$: $.pre.output_prefix
          executionId.$: $$.Execution.Name
    ResultSelector:
      seedHashZipS3Uri.$: $.seedHashZipS3Uri
      countyHashZipS3Uri.$: $.countyHashZipS3Uri
      combinedHashCsvS3Uri.$: $.combinedHashCsvS3Uri
      county.$: $.county
      executionId.$: $$.Execution.Name
      propertyCid.$: $.propertyCid
      transactionItems.$: $.transactionItems
    ResultPath: $.hash
    Next: EmitHashSucceeded
    Retry:
      - ErrorEquals: [States.Timeout]
        IntervalSeconds: 5
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.hashError
        Next: WaitForHashResolution

  EmitHashSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SUCCEEDED event for Hash step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: Hash
            step: Hash
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: EmitUploadScheduled
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: EmitUploadScheduled

  WaitForHashResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    Comment: "Emit FAILED event and wait for external resolution - retry target is Hash"
    HeartbeatSeconds: 2592000 # 30 days
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: FAILED
            phase: Hash
            step: Hash
            dataGroupLabel: County
            taskToken.$: $$.Task.Token
            errors:
              - code: "40001"
                details:
                  error.$: States.JsonToString($.hashError)
    ResultPath: $.resolutionResult
    Next: Hash
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        ResultPath: $.hashError
        Next: WaitForHashResolution

  # === UPLOAD STEP ===

  EmitUploadScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for Upload step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: Upload
            step: Upload
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: Upload
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: Upload

  Upload:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Run Upload to IPFS via SQS + Lambda worker"
    Parameters:
      QueueUrl: ${UploadQueueUrl}
      MessageBody:
        taskToken.$: $$.Task.Token
        input:
          seedHashZipS3Uri.$: $.hash.seedHashZipS3Uri
          countyHashZipS3Uri.$: $.hash.countyHashZipS3Uri
          county.$: $.pre.county_name
          executionId.$: $$.Execution.Name
    ResultSelector:
      uploadSuccess.$: $.uploadSuccess
      county.$: $.county
      executionId.$: $$.Execution.Name
    ResultPath: $.upload
    Next: EmitUploadSucceeded
    Retry:
      - ErrorEquals: [States.Timeout]
        IntervalSeconds: 5
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [UploadFailedError]
        Comment: "Upload to IPFS failed - park for resolution"
        ResultPath: $.uploadError
        Next: WaitForUploadResolution
      - ErrorEquals: [States.ALL]
        ResultPath: $.uploadError
        Next: WaitForUploadResolution

  EmitUploadSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SUCCEEDED event for Upload step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: Upload
            step: Upload
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: EmitSubmitScheduled
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: EmitSubmitScheduled

  WaitForUploadResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    Comment: "Emit FAILED event and wait for external resolution - retry target is Upload"
    HeartbeatSeconds: 2592000 # 30 days
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: FAILED
            phase: Upload
            step: Upload
            dataGroupLabel: County
            taskToken.$: $$.Task.Token
            errors:
              - code: "50001"
                details:
                  error.$: States.JsonToString($.uploadError)
    ResultPath: $.resolutionResult
    Next: Upload
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        ResultPath: $.uploadError
        Next: WaitForUploadResolution

  # === SUBMIT PHASE ===

  EmitSubmitScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for Submit phase"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: Submit
            step: Submit
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: GetGasPriceFromSSM
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: GetGasPriceFromSSM

  # === GAS PRICE CHECK STEP (SSM-based, no Lambda polling) ===
  # Gas price is updated every 5 minutes by GasPriceUpdater cron job Lambda
  # Step Function reads SSM directly and uses Choice state to decide
  # Time-based retry: 5 min during 17:00-05:00 UTC, 1 hour during 05:00-17:00 UTC

  GetGasPriceFromSSM:
    Type: Task
    Resource: arn:aws:states:::aws-sdk:ssm:getParameter
    Comment: "Read current gas price from SSM Parameter (updated by cron job)"
    Parameters:
      Name: ${GasPriceParameterName}
    ResultSelector:
      value.$: States.StringToJson($.Parameter.Value)
    ResultPath: $.gasPriceResult
    Next: CheckGasPriceChoice
    Retry:
      - ErrorEquals: [States.ALL]
        IntervalSeconds: 5
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.gasPriceError
        Next: DetermineGasPriceWaitInterval

  CheckGasPriceChoice:
    Type: Choice
    Comment: "Compare gas price from SSM against configured max threshold (${GasPriceMaxGwei} Gwei)"
    Choices:
      # If gasPrice <= maxGwei, proceed to submit
      - Variable: $.gasPriceResult.value.gasPrice
        NumericLessThanEquals: ${GasPriceMaxGwei}
        Next: EmitSubmitToBlockchainScheduled
    Default: DetermineGasPriceWaitInterval

  DetermineGasPriceWaitInterval:
    Type: Pass
    QueryLanguage: JSONata
    Comment: "Determine wait interval based on UTC hour: 5 min (300s) for 17:00-05:00 UTC, 1 hour (3600s) for 05:00-17:00 UTC"
    Output: >-
      {%
        (
          $hour := $number($substring($now(), 11, 2));
          $isOffPeak := $hour >= 17 or $hour < 5;
          $waitSeconds := $isOffPeak ? 300 : 3600;
          $merge([$states.input, { "gasPriceWaitSeconds": $waitSeconds }])
        )
      %}
    Next: WaitForGasPrice

  WaitForGasPrice:
    Type: Wait
    Comment: "Wait based on time of day before checking gas price again"
    SecondsPath: $.gasPriceWaitSeconds
    Next: GetGasPriceFromSSM

  # === SUBMIT TO BLOCKCHAIN STEP ===

  EmitSubmitToBlockchainScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for Submit to Blockchain step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: Submit
            step: SubmitToBlockchain
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: SubmitToBlockchain
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: SubmitToBlockchain

  SubmitToBlockchain:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Submit transaction items to blockchain"
    Parameters:
      QueueUrl: ${TransactionsSqsQueueUrl}
      MessageBody.$: States.JsonToString($.hash.transactionItems)
      MessageAttributes:
        TaskToken:
          DataType: String
          StringValue.$: $$.Task.Token
        ExecutionArn:
          DataType: String
          StringValue.$: $$.Execution.Name
        County:
          DataType: String
          StringValue.$: $.pre.county_name
        DataGroupLabel:
          DataType: String
          StringValue: "County"
    ResultSelector:
      taskToken.$: $$.Task.Token
      result.$: $
    ResultPath: $.submit
    Next: EmitSubmitSucceeded
    Retry:
      - ErrorEquals:
          - Sqs.RequestThrottledException
          - Sqs.ThrottlingException
          - Sqs.ServiceUnavailableException
          - Sqs.InternalFailureException
        IntervalSeconds: 2
        MaxAttempts: 2
        BackoffRate: 2
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.submitError
        Next: EmitSubmitFailed

  EmitSubmitSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SUCCEEDED event for Submit to Blockchain step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: Submit
            step: SubmitToBlockchain
            dataGroupLabel: County
    ResultPath: $.eventResult
    Next: ExtractTransactionHash
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: ExtractTransactionHash

  EmitSubmitFailed:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    QueryLanguage: JSONata
    Comment: "Emit FAILED event for Submit to Blockchain step with error code from lambda"
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: Submit
            step: SubmitToBlockchain
            dataGroupLabel: County
            errors:
              - code: "{% $states.input.submitError.Error %}"
                details:
                  cause: "{% $states.input.submitError.Cause %}"
    Output: "{% $merge([$states.input, { 'eventResult': $states.result }]) %}"
    Next: WaitForSubmitResolution
    Catch:
      - ErrorEquals: [States.ALL]
        Output: "{% $merge([$states.input, { 'eventError': $states.errorOutput }]) %}"
        Next: WaitForSubmitResolution

  WaitForSubmitResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    QueryLanguage: JSONata
    Comment: "Emit FAILED event and wait for external resolution - retry target is SubmitToBlockchain"
    HeartbeatSeconds: 2592000 # 30 days
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: Submit
            step: SubmitToBlockchain
            dataGroupLabel: County
            taskToken: "{% $states.context.Task.Token %}"
            errors:
              - code: "{% $states.input.submitError.Error %}"
                details:
                  cause: "{% $states.input.submitError.Cause %}"
    Output: "{% $merge([$states.input, { 'resolutionResult': $states.result }]) %}"
    Next: SubmitToBlockchain
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        Output: "{% $merge([$states.input, { 'submitError': $states.errorOutput }]) %}"
        Next: WaitForSubmitResolution

  # === TRANSACTION STATUS CHECK STEP ===

  ExtractTransactionHash:
    Type: Pass
    Parameters:
      submit.$: $.submit
      hash.$: $.hash
      executionId.$: $$.Execution.Name
      county.$: $.pre.county_name
      transactionHash.$: $.submit.result.submitResults[0].transactionHash
      transactionItems.$: $.hash.transactionItems
    ResultPath: $.transactionStatus
    Next: CheckTransactionStatusIfHashExists

  CheckTransactionStatusIfHashExists:
    Type: Choice
    Comment: "Only check transaction status if hash exists"
    Choices:
      - Variable: $.transactionStatus.transactionHash
        IsPresent: true
        Next: EmitTransactionStatusCheckScheduled
    Default: WorkflowComplete

  EmitTransactionStatusCheckScheduled:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SCHEDULED event for Transaction Status Check step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SCHEDULED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
    ResultPath: $.eventResult
    Next: PrepareTransactionStatusCheckDetail
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: PrepareTransactionStatusCheckDetail

  PrepareTransactionStatusCheckDetail:
    Type: Pass
    Parameters:
      transactionHash.$: $.transactionStatus.transactionHash
      transactionItems.$: $.transactionStatus.transactionItems
    ResultPath: $.transactionStatusCheckInput
    Next: InitializeTransactionStatusRetry

  InitializeTransactionStatusRetry:
    Type: Pass
    Comment: "Initialize transaction status retry counter to 0"
    Result: 0
    ResultPath: $.txStatusRetryCount
    Next: CheckTransactionStatus

  CheckTransactionStatus:
    Type: Task
    Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
    Comment: "Check transaction status on blockchain - routes based on error code"
    Parameters:
      QueueUrl: ${TransactionStatusCheckerSqsQueueUrl}
      MessageBody.$: States.JsonToString($.transactionStatusCheckInput)
      MessageAttributes:
        TaskToken:
          DataType: String
          StringValue.$: $$.Task.Token
        ExecutionArn:
          DataType: String
          StringValue.$: $$.Execution.Name
        County:
          DataType: String
          StringValue.$: $.pre.county_name
        DataGroupLabel:
          DataType: String
          StringValue: "County"
        TransactionHash:
          DataType: String
          StringValue.$: $.transactionStatus.transactionHash
    ResultSelector:
      taskToken.$: $$.Task.Token
      result.$: $
    ResultPath: $.transactionStatusCheck
    Next: EmitTransactionStatusCheckSucceeded
    Catch:
      # 60004: PENDING - transaction in mempool, wait and retry
      - ErrorEquals: ["60004"]
        ResultPath: $.transactionStatusError
        Next: HandleTransactionPending
      # 60005: NOT_FOUND - transaction dropped, go back to gas price check (resubmit)
      - ErrorEquals: ["60005"]
        ResultPath: $.transactionStatusError
        Next: HandleTransactionNotFound
      # 60003: FAILED - transaction reverted, wait for resolution then resubmit
      - ErrorEquals: ["60003"]
        ResultPath: $.transactionStatusError
        Next: HandleTransactionFailed
      # 60006 or other: GENERAL_ERROR - wait for resolution then retry status check
      - ErrorEquals: [States.ALL]
        ResultPath: $.transactionStatusError
        Next: HandleTransactionGeneralError

  # === PENDING: Retry indefinitely with exponential backoff (2^n seconds, max 12 hours) ===

  HandleTransactionPending:
    Type: Pass
    Comment: "Transaction pending - proceed to exponential backoff wait"
    Next: CalculateTransactionStatusWait

  CalculateTransactionStatusWait:
    Type: Pass
    QueryLanguage: JSONata
    Comment: "Calculate exponential backoff wait time: min(2^retryCount * 60, 43200) seconds (max 12 hours)"
    Output: >-
      {%
        (
          $baseInterval := 60;
          $maxInterval := 43200;
          $calculated := $power(2, $states.input.txStatusRetryCount) * $baseInterval;
          $waitSeconds := $min([$calculated, $maxInterval]);
          $merge([$states.input, {
            "txStatusRetryCount": $states.input.txStatusRetryCount + 1,
            "txStatusWaitSeconds": $waitSeconds
          }])
        )
      %}
    Next: WaitForTransactionStatus

  WaitForTransactionStatus:
    Type: Wait
    Comment: "Wait with exponential backoff before checking transaction status again"
    SecondsPath: $.txStatusWaitSeconds
    Next: CheckTransactionStatus

  # === NOT_FOUND: Transaction dropped, go back to gas price check (resubmit) ===

  HandleTransactionNotFound:
    Type: Pass
    Comment: "Transaction not found (dropped), prepare to resubmit"
    Next: EmitTransactionStatusCheckFailedThenResubmit

  # === FAILED: Transaction reverted, wait for resolution then resubmit ===

  HandleTransactionFailed:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    QueryLanguage: JSONata
    Comment: "Emit FAILED event for transaction that reverted on blockchain"
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
            dataGroupLabel: County
            errors:
              - code: "60003"
                details:
                  cause: "{% $states.input.transactionStatusError.Cause %}"
    Output: "{% $merge([$states.input, { 'eventResult': $states.result }]) %}"
    Next: WaitForTransactionFailedResolution
    Catch:
      - ErrorEquals: [States.ALL]
        Output: "{% $merge([$states.input, { 'eventError': $states.errorOutput }]) %}"
        Next: WaitForTransactionFailedResolution

  WaitForTransactionFailedResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    QueryLanguage: JSONata
    Comment: "Wait for resolution of failed transaction - then go back to gas price check (resubmit)"
    HeartbeatSeconds: 2592000 # 30 days
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
            dataGroupLabel: County
            taskToken: "{% $states.context.Task.Token %}"
            errors:
              - code: "60003"
                details:
                  cause: "{% $states.input.transactionStatusError.Cause %}"
    Output: "{% $merge([$states.input, { 'resolutionResult': $states.result }]) %}"
    Next: GetGasPriceFromSSM
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        Output: "{% $merge([$states.input, { 'transactionStatusError': $states.errorOutput }]) %}"
        Next: WaitForTransactionFailedResolution

  # === GENERAL_ERROR: Wait for resolution then retry status check ===

  HandleTransactionGeneralError:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    QueryLanguage: JSONata
    Comment: "Emit FAILED event for general error (RPC, config, etc.)"
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
            dataGroupLabel: County
            errors:
              - code: "{% $states.input.transactionStatusError.Error %}"
                details:
                  cause: "{% $states.input.transactionStatusError.Cause %}"
    Output: "{% $merge([$states.input, { 'eventResult': $states.result }]) %}"
    Next: WaitForTransactionGeneralErrorResolution
    Catch:
      - ErrorEquals: [States.ALL]
        Output: "{% $merge([$states.input, { 'eventError': $states.errorOutput }]) %}"
        Next: WaitForTransactionGeneralErrorResolution

  WaitForTransactionGeneralErrorResolution:
    Type: Task
    Resource: arn:aws:states:::events:putEvents.waitForTaskToken
    QueryLanguage: JSONata
    Comment: "Wait for resolution of general error - then retry status check"
    HeartbeatSeconds: 2592000 # 30 days
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
            dataGroupLabel: County
            taskToken: "{% $states.context.Task.Token %}"
            errors:
              - code: "{% $states.input.transactionStatusError.Error %}"
                details:
                  cause: "{% $states.input.transactionStatusError.Cause %}"
    Output: "{% $merge([$states.input, { 'resolutionResult': $states.result }]) %}"
    Next: InitializeTransactionStatusRetry
    Catch:
      - ErrorEquals: [States.ALL]
        Comment: "Resolution failed - stay parked and wait again"
        Output: "{% $merge([$states.input, { 'transactionStatusError': $states.errorOutput }]) %}"
        Next: WaitForTransactionGeneralErrorResolution

  # === RESUBMIT: Emit failure event then go back to gas price check ===

  EmitTransactionStatusCheckFailedThenResubmit:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    QueryLanguage: JSONata
    Comment: "Emit FAILED event then go back to gas price check (resubmit transaction)"
    Arguments:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId: "{% $states.context.Execution.Name %}"
            county: "{% $states.input.pre.county_name %}"
            status: FAILED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
            dataGroupLabel: County
            errors:
              - code: "{% $states.input.transactionStatusError.Error %}"
                details:
                  cause: "{% $states.input.transactionStatusError.Cause %}"
    Output: "{% $merge([$states.input, { 'eventResult': $states.result }]) %}"
    Next: GetGasPriceFromSSM
    Catch:
      - ErrorEquals: [States.ALL]
        Output: "{% $merge([$states.input, { 'eventError': $states.errorOutput }]) %}"
        Next: GetGasPriceFromSSM

  EmitTransactionStatusCheckSucceeded:
    Type: Task
    Resource: arn:aws:states:::events:putEvents
    Comment: "Emit SUCCEEDED event for Transaction Status Check step"
    Parameters:
      Entries:
        - Source: elephant.workflow
          DetailType: WorkflowEvent
          Detail:
            executionId.$: $$.Execution.Name
            county.$: $.pre.county_name
            status: SUCCEEDED
            phase: TransactionStatusCheck
            step: CheckTransactionStatus
    ResultPath: $.eventResult
    Next: WorkflowComplete
    Catch:
      - ErrorEquals: [States.ALL]
        ResultPath: $.eventError
        Next: WorkflowComplete

  WorkflowComplete:
    Type: Succeed
