/**
 * @module @elephant/shared/reprocessing
 * @description Shared utilities for reprocessing workflow operations
 */

import { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';
import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import AdmZip from 'adm-zip';
import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import { createLogEntry } from './index.js';

const lambda = new LambdaClient({});
const s3 = new S3Client({});

/**
 * Downloads and extracts a script zip file from S3
 * @function downloadAndExtractScripts
 * @param {string} bucket - S3 bucket name
 * @param {string} key - S3 key of the zip file
 * @param {string} [tmpDir] - Temporary directory to extract to (defaults to system temp)
 * @returns {Promise<string>} Path to the extracted directory
 * @throws {Error} If download or extraction fails
 * @example
 * import { downloadAndExtractScripts } from '@elephant/shared/reprocessing';
 * const scriptsPath = await downloadAndExtractScripts('my-bucket', 'scripts/transform.zip');
 */
export async function downloadAndExtractScripts(bucket, key, tmpDir = os.tmpdir()) {
    const log = (level, msg, details = {}) => console.log(JSON.stringify(createLogEntry('auto-repair', level, msg, details)));

    try {
        log('info', 'downloading_scripts_zip', { bucket, key });

        const getObjectCommand = new GetObjectCommand({
            Bucket: bucket,
            Key: key
        });

        const response = await s3.send(getObjectCommand);
        const zipBuffer = await response.Body.transformToByteArray();

        // Create temporary directory for extraction
        const extractDir = path.join(tmpDir, `scripts-${Date.now()}`);
        await fs.mkdir(extractDir, { recursive: true });

        // Extract zip file
        const zip = new AdmZip(Buffer.from(zipBuffer));
        zip.extractAllTo(extractDir, true);

        log('info', 'scripts_extracted_successfully', { extractDir });
        return extractDir;

    } catch (error) {
        log('error', 'failed_to_download_extract_scripts', { error: error.message, bucket, key });
        throw new Error(`Failed to download and extract scripts: ${error.message}`);
    }
}

/**
 * Parses S3 URI to extract bucket and key
 * @function parseS3Uri
 * @param {string} s3Uri - S3 URI in format s3://bucket/key
 * @returns {{bucket: string, key: string}} Parsed bucket and key
 * @throws {Error} If URI format is invalid
 * @example
 * import { parseS3Uri } from '@elephant/shared/reprocessing';
 * const { bucket, key } = parseS3Uri('s3://my-bucket/path/to/file.zip');
 */
export function parseS3Uri(s3Uri) {
    if (!s3Uri.startsWith('s3://')) {
        throw new Error(`Invalid S3 URI format: ${s3Uri}`);
    }

    const withoutPrefix = s3Uri.substring(5); // Remove 's3://'
    const firstSlashIndex = withoutPrefix.indexOf('/');

    if (firstSlashIndex === -1) {
        throw new Error(`Invalid S3 URI format: ${s3Uri}`);
    }

    const bucket = withoutPrefix.substring(0, firstSlashIndex);
    const key = withoutPrefix.substring(firstSlashIndex + 1);

    return { bucket, key };
}

/**
 * Invokes the post-processor lambda to reprocess a record
 * @function invokePostProcessor
 * @param {string} functionName - Name of the post-processor lambda function
 * @param {Object} payload - Payload to send to the lambda
 * @param {string} payload.s3 - S3 event information
 * @param {Object} payload.prepare - Prepare step output
 * @param {string} payload.seed_output_s3_uri - Seed output S3 URI
 * @returns {Promise<Object>} Lambda invocation result
 * @throws {Error} If invocation fails
 * @example
 * import { invokePostProcessor } from '@elephant/shared/reprocessing';
 * const result = await invokePostProcessor('MyPostProcessor', {
 *   s3: s3Event,
 *   prepare: prepareOutput,
 *   seed_output_s3_uri: 's3://bucket/seed.zip'
 * });
 */
export async function invokePostProcessor(functionName, payload) {
    const log = (level, msg, details = {}) => console.log(JSON.stringify(createLogEntry('auto-repair', level, msg, details)));

    try {
        log('info', 'invoking_post_processor', { functionName, payloadKeys: Object.keys(payload) });

        const invokeCommand = new InvokeCommand({
            FunctionName: functionName,
            Payload: JSON.stringify(payload),
            InvocationType: 'RequestResponse'
        });

        const response = await lambda.send(invokeCommand);

        if (response.FunctionError) {
            const errorPayload = JSON.parse(new TextDecoder().decode(response.Payload));
            throw new Error(`Post-processor invocation failed: ${errorPayload.errorMessage}`);
        }

        const result = JSON.parse(new TextDecoder().decode(response.Payload));
        log('info', 'post_processor_invoked_successfully', { status: result.status });

        return result;

    } catch (error) {
        log('error', 'failed_to_invoke_post_processor', { error: error.message, functionName });
        throw new Error(`Failed to invoke post-processor: ${error.message}`);
    }
}

/**
 * Invokes the submit lambda to process transaction items
 * @function invokeSubmitProcessor
 * @param {string} functionName - Name of the submit lambda function
 * @param {Array} transactionItems - Array of transaction items to submit
 * @param {Object} [additionalParams] - Additional parameters for submission
 * @returns {Promise<Object>} Lambda invocation result
 * @throws {Error} If invocation fails
 * @example
 * import { invokeSubmitProcessor } from '@elephant/shared/reprocessing';
 * const result = await invokeSubmitProcessor('MySubmitProcessor', transactionItems, {
 *   domain: 'api.example.com',
 *   apiKey: 'secret-key'
 * });
 */
export async function invokeSubmitProcessor(functionName, transactionItems, additionalParams = {}) {
    const log = (level, msg, details = {}) => console.log(JSON.stringify(createLogEntry('auto-repair', level, msg, details)));

    try {
        log('info', 'invoking_submit_processor', {
            functionName,
            itemCount: transactionItems.length,
            additionalParamsKeys: Object.keys(additionalParams)
        });

        const payload = {
            transactionItems,
            ...additionalParams
        };

        const invokeCommand = new InvokeCommand({
            FunctionName: functionName,
            Payload: JSON.stringify(payload),
            InvocationType: 'RequestResponse'
        });

        const response = await lambda.send(invokeCommand);

        if (response.FunctionError) {
            const errorPayload = JSON.parse(new TextDecoder().decode(response.Payload));
            throw new Error(`Submit-processor invocation failed: ${errorPayload.errorMessage}`);
        }

        const result = JSON.parse(new TextDecoder().decode(response.Payload));
        log('info', 'submit_processor_invoked_successfully', { status: result.status });

        return result;

    } catch (error) {
        log('error', 'failed_to_invoke_submit_processor', { error: error.message, functionName });
        throw new Error(`Failed to invoke submit-processor: ${error.message}`);
    }
}
