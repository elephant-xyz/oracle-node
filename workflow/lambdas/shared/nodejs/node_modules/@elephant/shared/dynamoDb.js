/**
 * @module @elephant/shared/dynamoDb
 * @description DynamoDB utilities for Elephant Lambda functions
 */

import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { createHash } from 'crypto';

// Initialize DynamoDB clients
const client = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(client);


/**
 * Creates a hash from an error message using Node.js crypto capabilities
 * @function createErrorHash
 * @param {string} errorMessage - The error message to hash
 * @returns {string} A SHA-256 hexadecimal hash string (first 16 characters)
 * @private
 */
function createErrorHash(errorMessage) {
    return createHash('sha256')
        .update(errorMessage)
        .digest('hex')
        .substring(0, 16);
}

/**
 * Error type for DynamoDB operations
 * @typedef {Object} ErrorType
 * @property {string} pk - Partition key in format ERROR#<hash>
 * @property {string} sk - Sort key in format ERROR#<hash>
 * @property {boolean} resolved - Whether the error has been resolved (default: false)
 * @property {boolean} locked - Whether the error has been locked (default: false)
 * @property {string} createdAt - ISO timestamp when error was created
 */

/**
 * Error entry interface for DynamoDB operations
 * @typedef {Object} ErrorEntry
 * @property {string} pk - Partition key in format ERROR#<hash>
 * @property {string} sk - Sort key in format TIMESTAMP#<timestamp>
 * @property {string} errorMessage - The full error message
 * @property {string} countyName - Name of the county where error occurred
 * @property {string} transformedZip - S3 key of the transformed zip file
 * @property {string} createdAt - ISO timestamp when error was created
 */

/**
 * Creates a new error entry in DynamoDB
 * @function createErrorEntry
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message
 * @param {string} countyName - Name of the county where error occurred
 * @param {string} transformedZip - S3 key of the transformed zip file
 * @returns {Promise<ErrorEntry>} The created error entry
 * @throws {Error} If the operation fails
 * @example
 * import { createErrorEntry } from '@elephant/shared';
 * const error = await createErrorEntry('ErrorsTable', 'Validation failed', 'Miami-Dade', 'outputs/transformed.zip');
 */
export async function createErrorEntry(tableName, errorMessage, countyName, transformedZip) {
    const errorHash = createErrorHash(errorMessage);
    const timestamp = new Date().toISOString();

    const errorEntry = {
        pk: `ERROR#${errorHash}`,
        sk: `TIMESTAMP#${timestamp}`,
        errorMessage,
        countyName,
        transformedZip,
        createdAt: timestamp
    };

    const command = new PutCommand({
        TableName: tableName,
        Item: errorEntry,
        ConditionExpression: 'attribute_not_exists(pk) AND attribute_not_exists(sk)'
    });

    try {
        await docClient.send(command);
        return errorEntry;
    } catch (error) {
        throw new Error(`Failed to create error entry: ${error.message}`);
    }
}

/**
 * Queries all error entries with the same error hash
 * @function queryErrorsByHash
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message to search for
 * @returns {Promise<ErrorEntry[]>} Array of error entries with the same hash
 * @throws {Error} If the query fails
 * @example
 * import { queryErrorsByHash } from '@elephant/shared';
 * const errors = await queryErrorsByHash('ErrorsTable', 'Validation failed');
 */
export async function queryErrorsByHash(tableName, errorMessage) {
    const errorHash = createErrorHash(errorMessage);

    const command = new QueryCommand({
        TableName: tableName,
        KeyConditionExpression: 'pk = :pk',
        ExpressionAttributeValues: {
            ':pk': `ERROR#${errorHash}`
        },
        ScanIndexForward: false // Most recent first
    });

    try {
        const response = await docClient.send(command);
        return response.Items || [];
    } catch (error) {
        throw new Error(`Failed to query errors by hash: ${error.message}`);
    }
}

/**
 * Upserts an ErrorType entity in DynamoDB
 * @function upsertErrorType
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message to create/update error type for
 * @param {Object} [additionalAttributes] - Additional attributes to set on the error type
 * @returns {Promise<ErrorType>} The upserted error type entry
 * @throws {Error} If the operation fails
 * @example
 * import { upsertErrorType } from '@elephant/shared/dynamoDb';
 * const errorType = await upsertErrorType('ErrorsTable', 'Validation failed');
 */
export async function upsertErrorType(tableName, errorMessage, additionalAttributes = {}) {
    const errorHash = createErrorHash(errorMessage);
    const timestamp = new Date().toISOString();

    const updateExpression = [
        'SET #resolved = if_not_exists(#resolved, :resolved)',
        'SET #locked = if_not_exists(#locked, :locked)',
        'SET #createdAt = if_not_exists(#createdAt, :createdAt)',
        ...Object.keys(additionalAttributes).map(attr => `SET #${attr} = :${attr}`)
    ].join(', ');

    const expressionAttributeNames = {
        '#resolved': 'resolved',
        '#locked': 'locked',
        '#createdAt': 'createdAt',
        ...Object.keys(additionalAttributes).reduce((acc, attr) => {
            acc[`#${attr}`] = attr;
            return acc;
        }, {})
    };

    const expressionAttributeValues = {
        ':resolved': false,
        ':locked': false,
        ':createdAt': timestamp,
        ...additionalAttributes
    };

    const command = new UpdateCommand({
        TableName: tableName,
        Key: {
            pk: `ERROR#${errorHash}`,
            sk: `ERROR#${errorHash}`
        },
        UpdateExpression: updateExpression,
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ConditionExpression: 'attribute_not_exists(pk) OR (attribute_exists(pk) AND resolved = :false AND locked = :false)',
        ReturnValues: 'ALL_NEW'
    });

    try {
        const response = await docClient.send(command);
        return response.Attributes;
    } catch (error) {
        throw new Error(`Failed to upsert error type: ${error.message}`);
    }
}

/**
 * Acquires a lock on an ErrorType entity
 * @function acquireLock
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message to acquire lock for
 * @returns {Promise<ErrorType>} The updated error type entry with lock acquired
 * @throws {Error} If the operation fails or lock cannot be acquired
 * @example
 * import { acquireLock } from '@elephant/shared/dynamoDb';
 * const lockedErrorType = await acquireLock('ErrorsTable', 'Validation failed');
 */
export async function acquireLock(tableName, errorMessage) {
    const errorHash = createErrorHash(errorMessage);

    const command = new UpdateCommand({
        TableName: tableName,
        Key: {
            pk: `ERROR#${errorHash}`,
            sk: `ERROR#${errorHash}`
        },
        UpdateExpression: 'SET locked = :locked',
        ExpressionAttributeValues: {
            ':locked': true,
            ':currentLocked': false
        },
        ConditionExpression: 'locked = :currentLocked AND attribute_exists(pk)',
        ReturnValues: 'ALL_NEW'
    });

    try {
        const response = await docClient.send(command);
        return response.Attributes;
    } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
            throw new Error(`Failed to acquire lock: Error type is already locked or does not exist`);
        }
        throw new Error(`Failed to acquire lock: ${error.message}`);
    }
}

/**
 * Releases the lock and marks an ErrorType entity as resolved
 * @function releaseLockAndResolve
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message to release lock and resolve for
 * @returns {Promise<ErrorType>} The updated error type entry with lock released and resolved
 * @throws {Error} If the operation fails or lock cannot be released
 * @example
 * import { releaseLockAndResolve } from '@elephant/shared/dynamoDb';
 * const resolvedErrorType = await releaseLockAndResolve('ErrorsTable', 'Validation failed');
 */
export async function releaseLockAndResolve(tableName, errorMessage) {
    const errorHash = createErrorHash(errorMessage);

    const command = new UpdateCommand({
        TableName: tableName,
        Key: {
            pk: `ERROR#${errorHash}`,
            sk: `ERROR#${errorHash}`
        },
        UpdateExpression: 'SET locked = :locked, resolved = :resolved, resolvedAt = :resolvedAt',
        ExpressionAttributeValues: {
            ':locked': false,
            ':resolved': true,
            ':currentLocked': true,
            ':resolvedAt': new Date().toISOString()
        },
        ConditionExpression: 'locked = :currentLocked AND attribute_exists(pk)',
        ReturnValues: 'ALL_NEW'
    });

    try {
        const response = await docClient.send(command);
        return response.Attributes;
    } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
            throw new Error(`Failed to release lock and resolve: Error type is not locked or does not exist`);
        }
        throw new Error(`Failed to release lock and resolve: ${error.message}`);
    }
}
