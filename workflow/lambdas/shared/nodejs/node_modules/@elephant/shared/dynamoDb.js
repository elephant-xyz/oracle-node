/**
 * @module @elephant/shared/dynamoDb
 * @description DynamoDB utilities for Elephant Lambda functions
 */

import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { createHash } from 'crypto';

// Initialize DynamoDB clients
const client = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(client);


/**
 * Creates a hash from an error message using Node.js crypto capabilities
 * @function createErrorHash
 * @param {string} errorMessage - The error message to hash
 * @returns {string} A SHA-256 hexadecimal hash string (first 16 characters)
 * @private
 */
function createErrorHash(errorMessage) {
    return createHash('sha256')
        .update(errorMessage)
        .digest('hex')
        .substring(0, 16);
}

/**
 * Error entry interface for DynamoDB operations
 * @typedef {Object} ErrorEntry
 * @property {string} pk - Partition key in format ERROR#<hash>
 * @property {string} sk - Sort key in format TIMESTAMP#<timestamp>
 * @property {string} errorMessage - The full error message
 * @property {string} countyName - Name of the county where error occurred
 * @property {string} transformedZip - S3 key of the transformed zip file
 * @property {boolean} resolved - Whether the error has been resolved (default: false)
 * @property {string} createdAt - ISO timestamp when error was created
 */

/**
 * Creates a new error entry in DynamoDB
 * @function createErrorEntry
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message
 * @param {string} countyName - Name of the county where error occurred
 * @param {string} transformedZip - S3 key of the transformed zip file
 * @returns {Promise<ErrorEntry>} The created error entry
 * @throws {Error} If the operation fails
 * @example
 * import { createErrorEntry } from '@elephant/shared';
 * const error = await createErrorEntry('ErrorsTable', 'Validation failed', 'Miami-Dade', 'outputs/transformed.zip');
 */
export async function createErrorEntry(tableName, errorMessage, countyName, transformedZip) {
    const errorHash = createErrorHash(errorMessage);
    const timestamp = new Date().toISOString();

    const errorEntry = {
        pk: `ERROR#${errorHash}`,
        sk: `TIMESTAMP#${timestamp}`,
        errorMessage,
        countyName,
        transformedZip,
        resolved: false,
        createdAt: timestamp
    };

    const command = new PutCommand({
        TableName: tableName,
        Item: errorEntry,
        ConditionExpression: 'attribute_not_exists(pk) AND attribute_not_exists(sk)'
    });

    try {
        await docClient.send(command);
        return errorEntry;
    } catch (error) {
        throw new Error(`Failed to create error entry: ${error.message}`);
    }
}

/**
 * Queries all error entries with the same error hash
 * @function queryErrorsByHash
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message to search for
 * @returns {Promise<ErrorEntry[]>} Array of error entries with the same hash
 * @throws {Error} If the query fails
 * @example
 * import { queryErrorsByHash } from '@elephant/shared';
 * const errors = await queryErrorsByHash('ErrorsTable', 'Validation failed');
 */
export async function queryErrorsByHash(tableName, errorMessage) {
    const errorHash = createErrorHash(errorMessage);

    const command = new QueryCommand({
        TableName: tableName,
        KeyConditionExpression: 'pk = :pk',
        ExpressionAttributeValues: {
            ':pk': `ERROR#${errorHash}`
        },
        ScanIndexForward: false // Most recent first
    });

    try {
        const response = await docClient.send(command);
        return response.Items || [];
    } catch (error) {
        throw new Error(`Failed to query errors by hash: ${error.message}`);
    }
}

/**
 * Marks an error entry as resolved
 * @function resolveError
 * @param {string} tableName - DynamoDB table name
 * @param {string} errorMessage - The error message
 * @param {string} timestamp - The timestamp when the error was created
 * @returns {Promise<ErrorEntry>} The updated error entry
 * @throws {Error} If the update fails
 * @example
 * import { resolveError } from '@elephant/shared';
 * const resolvedError = await resolveError('ErrorsTable', 'Validation failed', '2024-01-01T12:00:00.000Z');
 */
export async function resolveError(tableName, errorMessage, timestamp) {
    const errorHash = createErrorHash(errorMessage);

    const command = new UpdateCommand({
        TableName: tableName,
        Key: {
            pk: `ERROR#${errorHash}`,
            sk: `TIMESTAMP#${timestamp}`
        },
        UpdateExpression: 'SET resolved = :resolved, resolvedAt = :resolvedAt',
        ExpressionAttributeValues: {
            ':resolved': true,
            ':resolvedAt': new Date().toISOString()
        },
        ReturnValues: 'ALL_NEW',
        ConditionExpression: 'attribute_exists(pk) AND attribute_exists(sk)'
    });

    try {
        const response = await docClient.send(command);
        return response.Attributes;
    } catch (error) {
        throw new Error(`Failed to resolve error: ${error.message}`);
    }
}